{"version":3,"file":"resource.js","sources":["../../../src/core/function-based/resource.ts"],"sourcesContent":["import { assert } from '@ember/debug';\n// @ts-ignore\nimport { setHelperManager } from '@ember/helper';\n\nimport { ResourceManagerFactory } from './manager';\nimport { INTERNAL } from './types';\nimport { wrapForPlainUsage } from './utils';\n\nimport type { InternalFunctionResourceConfig, ResourceFn, ResourceFunction } from './types';\n\n/**\n * `resource` provides a single reactive read-only value with lifetime and may have cleanup.\n *\n * Arguments passed to the `resource` function:\n * ```js\n *  resource(\n *    ({\n *      // provided callback functions:\n *      //  - `cleanup`\n *      on,\n *\n *      // used for composing other resources\n *      use,\n *\n *      // used for accessing services, etc on the app/engine owner instance\n *      owner\n *    }) => {\n *      // ✂️  resource body ✂️\n *    }\n *  );\n *  ```\n *\n *  Example using `fetch` + `AbortController`\n *  ```js\n *  import { use, resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *  import { tracked } from '@glimmer/tracking';\n *\n *  class Demo {\n *    @tracked url = '...';\n *\n *    @use myData = resource(({ on }) => {\n *      let state = new TrackedObject({ ... });\n *\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      // because this.url is tracked, anytime url changes,\n *      // this resource will re-run\n *      fetch(this.url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *          // ...\n *        })\n *        .catch(error => {\n *          state.error = error;\n *          // ...\n *        });\n *      // Note that this fetch request could be written async by wrapping in an\n *      // immediately invoked async function, e.g: (async () => {})()\n *\n *\n *      return state;\n *    })\n *  }\n *  ```\n *\n *\n *\n *  Example using strict mode + `<template>` syntax and a template-only component:\n *\n *  ```js\n *  import { resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *\n *  const load = resource(({ on }) => {\n *    let state = new TrackedObject({});\n *    let controller = new AbortController();\n *\n *    on.cleanup(() => controller.abort());\n *\n *    fetch(this.url, { signal: controller.signal })\n *      .then(response => response.json())\n *      .then(data => {\n *        state.value = data;\n *      })\n *      .catch(error => {\n *        state.error = error;\n *      });\n *\n *    return state;\n *  })\n *\n *  <template>\n *    {{#let (load) as |state|}}\n *      {{#if state.value}}\n *        ...\n *      {{else if state.error}}\n *        {{state.error}}\n *      {{/if}}\n *    {{/let}}\n *  </template>\n *  ```\n */\nexport function resource<Value>(setup: ResourceFunction<Value>): Value;\n\n/**\n * `resource` is an alternative API to the class-based `Resource`.\n * It may provide a single read-only value and provides a way to optionally cleanup.\n *\n * When would you reach for the class-based `Resource`?\n *  - the capabilities of the function-based resource and class-based resource are identical,\n *    with the exception that function-based resources may represent a single value, rather than\n *    an object with properties/methods (the only option with class-based resources)\n *\n * A function-resource\n *  - _must_ return a value.\n *  - cannot, itself, be async - but can interact with promises and update a value\n *\n *  Example using `fetch` + `AbortController`\n *  ```js\n *  import { resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *  import { tracked } from '@glimmer/tracking';\n *\n *  class Demo {\n *    @tracked url = '...';\n *\n *    myData = resource(this, ({ on }) => {\n *      let state = new TrackedObject({ isResolved: false, isLoading: true, isError: false });\n *\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      // because this.url is tracked, anytime url changes,\n *      // this resource will re-run\n *      fetch(this.url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *          state.isResolved = true;\n *          state.isLoading = false;\n *          state.isError = false;\n *        })\n *        .catch(error => {\n *          state.error = error;\n *          state.isResolved = true;\n *          state.isLoading = false;\n *          state.isError = true;\n *        });\n *      // Note that this fetch request could be written async by wrapping in an\n *      // immediately invoked async function, e.g: (async () => {})()\n *\n *\n *      return state;\n *    })\n *  }\n *  ```\n */\nexport function resource<Value>(context: object, setup: ResourceFunction<Value>): Value;\n\n/**\n */\nexport function resource<Value>(\n  context: object | ResourceFunction<Value>,\n  setup?: ResourceFunction<Value>,\n): Value | InternalFunctionResourceConfig<Value> | ResourceFn<Value> {\n  if (!setup) {\n    assert(\n      `When using \\`resource\\` with @use, ` +\n        `the first argument to \\`resource\\` must be a function. ` +\n        `Instead, a ${typeof context} was received.`,\n      typeof context === 'function',\n    );\n\n    let internalConfig: InternalFunctionResourceConfig<Value> = {\n      definition: context as ResourceFunction<Value>,\n      type: 'function-based',\n      [INTERNAL]: true,\n    };\n\n    /**\n     * Functions have a different identity every time they are defined.\n     * The primary purpose of the `resource` wrapper is to individually\n     * register each function with our helper manager.\n     */\n    setHelperManager(ResourceManagerFactory, internalConfig);\n\n    /**\n     * With only one argument, we have to do a bunch of lying to\n     * TS, because we need a special object to pass to `@use`\n     *\n     * Add secret key to help @use assert against\n     * using vanilla functions as resources without the resource wrapper\n     *\n     */\n    return internalConfig as unknown as ResourceFn<Value>;\n  }\n\n  assert(\n    `Mismatched argument types passed to \\`resource\\`. ` +\n      `Expected the first arg, the context, to be a type of object. This is usually the \\`this\\`. ` +\n      `Received ${typeof context} instead.`,\n    typeof context === 'object',\n  );\n  assert(\n    `Mismatched argument type passed to \\`resource\\`. ` +\n      `Expected the second arg to be a function but instead received ${typeof setup}.`,\n    typeof setup === 'function',\n  );\n\n  let internalConfig: InternalFunctionResourceConfig<Value> = {\n    definition: setup as ResourceFunction<Value>,\n    type: 'function-based',\n    [INTERNAL]: true,\n  };\n\n  setHelperManager(ResourceManagerFactory, internalConfig);\n\n  return wrapForPlainUsage(context, internalConfig);\n}\n"],"names":["resource","context","setup","assert","internalConfig","definition","type","INTERNAL","setHelperManager","ResourceManagerFactory","wrapForPlainUsage"],"mappings":";;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACO,SAASA,QAAQA,CACtBC,OAAyC,EACzCC,KAA+B,EACoC;EACnE,IAAI,CAACA,KAAK,EAAE;AACVC,IAAAA,MAAM,CACH,CAAA,mCAAA,CAAoC,GAClC,CAAA,uDAAA,CAAwD,GACxD,CAAa,WAAA,EAAA,OAAOF,OAAQ,CAAA,cAAA,CAAe,EAC9C,OAAOA,OAAO,KAAK,UACrB,CAAC,CAAA;AAED,IAAA,IAAIG,cAAqD,GAAG;AAC1DC,MAAAA,UAAU,EAAEJ,OAAkC;AAC9CK,MAAAA,IAAI,EAAE,gBAAgB;AACtB,MAAA,CAACC,QAAQ,GAAG,IAAA;KACb,CAAA;;AAED;AACJ;AACA;AACA;AACA;AACIC,IAAAA,gBAAgB,CAACC,sBAAsB,EAAEL,cAAc,CAAC,CAAA;;AAExD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI,IAAA,OAAOA,cAAc,CAAA;AACvB,GAAA;AAEAD,EAAAA,MAAM,CACH,CAAA,kDAAA,CAAmD,GACjD,CAAA,2FAAA,CAA4F,GAC5F,CAAW,SAAA,EAAA,OAAOF,OAAQ,CAAA,SAAA,CAAU,EACvC,OAAOA,OAAO,KAAK,QACrB,CAAC,CAAA;AACDE,EAAAA,MAAM,CACH,CAAA,iDAAA,CAAkD,GAChD,CAAA,8DAAA,EAAgE,OAAOD,KAAM,CAAE,CAAA,CAAA,EAClF,OAAOA,KAAK,KAAK,UACnB,CAAC,CAAA;AAED,EAAA,IAAIE,cAAqD,GAAG;AAC1DC,IAAAA,UAAU,EAAEH,KAAgC;AAC5CI,IAAAA,IAAI,EAAE,gBAAgB;AACtB,IAAA,CAACC,QAAQ,GAAG,IAAA;GACb,CAAA;AAEDC,EAAAA,gBAAgB,CAACC,sBAAsB,EAAEL,cAAc,CAAC,CAAA;AAExD,EAAA,OAAOM,iBAAiB,CAACT,OAAO,EAAEG,cAAc,CAAC,CAAA;AACnD;;;;"}