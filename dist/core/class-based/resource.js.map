{"version":3,"file":"resource.js","sources":["../../../src/core/class-based/resource.ts"],"sourcesContent":["// @ts-ignore\nimport { getValue } from '@glimmer/tracking/primitives/cache';\nimport { setOwner } from '@ember/application';\nimport { deprecate } from '@ember/debug';\nimport { assert } from '@ember/debug';\n// @ts-ignore\nimport { invokeHelper } from '@ember/helper';\n\nimport { INTERNAL } from '../function-based/types';\nimport { DEFAULT_THUNK, normalizeThunk } from '../utils';\n\nimport type { AsThunk, Cache, Constructor, Named, Positional, Thunk } from '[core-types]';\nimport type Owner from '@ember/owner';\nimport type { HelperLike } from '@glint/template';\n// this lint thinks this type import is used by decorator metadata...\n// babel doesn't use decorator metadata\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport type { Invoke } from '@glint/template/-private/integration';\n\nlet loggedDeprecation = false;\n\n/**\n * @private utility type\n *\n * Returns the Thunk-cased args for a given Class/InstanceType of Resource\n */\nexport type ArgsFrom<Klass extends Resource<any>> = Klass extends Resource<infer Args>\n  ? Args\n  : never;\n\n/**\n * https://gist.github.com/dfreeman/e4728f2f48737b44efb99fa45e2d22ef#typing-the-return-value-implicitly\n *\n * This is a Glint helper to help HelperLike determine what the ReturnType is.\n */\ntype ResourceHelperLike<T, R> = InstanceType<\n  HelperLike<{\n    Args: {\n      Named: Named<T>;\n      Positional: Positional<T>;\n    };\n    Return: R;\n  }>\n>;\n\ndeclare const __ResourceArgs__: unique symbol;\n\n/**\n * The 'Resource' base class has only one lifecycle hook, `modify`, which is called during\n * instantiation of the resource as well as on every update of any of any consumed args.\n *\n * Typically, a `Resource` will be used to build higher-level APIs that you'd then use in your apps.\n * For example, maybe you want to build a reactive-wrapper around a non-reactive wrapper, XState\n * which requires that the \"State machine interpreter\"\n * is stopped when you are discarding the parent context (such as a component).\n *\n * _When would you reach for the class-based `Resource` instead of the function-based `resource`?_\n *\n *  - the capabilities of the function-based resource and class-based resource are almost identical.\n *    the main difference is that function-based resources may represent a single a value\n *    (which could, itself, be a class instance, or object with properties),\n *    class-based-resources expose the whole class instance to the consumer.\n *\n *  - function-based resources, however, are much easier to work with and understand, and have\n *    better intellisense capabilities.\n *\n *\n * An example\n * ```js\n * import { Resource } from 'ember-resources';\n * import { createMachine, interpret } from 'xstate';\n *\n * const machine = createMachine(); // ... see XState docs for this function this ...\n *\n * class MyResource extends Resource {\n *   @tracked customState;\n *\n *   constructor(owner) {\n *     super(owner);\n *\n *     registerDestructor(this, () => this.interpreter.stop());\n *   }\n *\n *   modify(positional, named) {\n *     if (!this.interpreter) {\n *       // Initial Setup\n *       this.interpreter = interpret(machine).onTransition(state => this.customState = state);\n *     } else {\n *       // Subsequent Updates\n *       this.interpreter.send('SOME_EVENT', { positional, named });\n *     }\n *   }\n * }\n * ```\n *\n * Once defined, there are two ways to use `MyResource`\n *  - in a template\n *  - in JavaScript\n *\n * In the template, the Resource can be imported (or re-exported from the helpers directory)\n *\n * When imported (using [RFC 779](https://github.com/emberjs/rfcs/pull/779)),\n * ```jsx gjs\n * import { MyResource } from './somewhere';\n *\n * <template>\n *   {{#let (MyResource) as |myResource|}}\n *     {{log myResource.customState}}\n *   {{/let}}\n * </template>\n *\n * ```\n *\n * When using in javascript, you'll need the `from` utility\n * ```ts\n * import { MyResource } from './somewhere';\n *\n * class ContainingClass {\n *   state = MyResource.from(this, () => [...])\n * }\n * ```\n * However, when authoring a Resource, it's useful to co-locate an export of a helper function:\n * ```js\n * export function myResource(destroyable, options) {\n *   return MyResource.from(destroyable, () => ({\n *     foo: () => options.foo,\n *     bar: () => options.bar,\n *   }))\n * }\n * ```\n *\n * This way, consumers only need one import.\n *\n * If your resource may be used with other resources in the same file,\n * class-based resources also work with use, which gives the benefit of\n * omitting the `this` parameter to `from`.\n *\n * ```js\n * import { use } from 'ember-resources';\n * import { MyResource } from './somewhere';\n * import { SomeRequest } from './somewhere-else';\n * import { WebSocket } from './connection';\n *\n * class ContainingClass {\n *   @use state = MyResource.from(() => [...])\n *   @use request = SomeRequest.from(() => [...])\n *   @use socket = WebSocket.from(() => [...])\n * }\n * ```\n *\n */\nexport class Resource<Args = unknown> {\n  /**\n   * @private (secret)\n   *\n   * Because classes are kind of like interfaces,\n   * we need \"something\" to help TS know what a Resource is.\n   *\n   * This isn't a real API, but does help with type inference\n   * with the ArgsFrom utility above\n   */\n  public declare [__ResourceArgs__]: Args;\n\n  /**\n   * @private (secret)\n   *\n   * This is a lie, but a useful one for Glint, because\n   * Glint's \"HelperLike\" matches on this \"Invoke\" property.\n   *\n   * Faking the interface of `HelperLike` is the only way we can get Glint to treat\n   *  class-based resources as helpers in templates.\n   *\n   * If subclassing was not needed, we could just \"merge the interface\" with Resource\n   * and HelperLike, but merged interfaces are not retained in subclasses.\n   *\n   * Without this, the static method, from, would have a type error.\n   */\n  declare [Invoke]: ResourceHelperLike<Args, this>[typeof Invoke];\n\n  /**\n   * For use in the body of a class.\n   *\n   * `from` is what allows resources to be used in JS, they hide the reactivity APIs\n   * from the consumer so that the surface API is smaller.\n   *\n   * ```js\n   * import { Resource, use } from 'ember-resources';\n   *\n   * class SomeResource extends Resource {}\n   *\n   * class MyClass {\n   *   @use data = SomeResource.from(() => [ ... ]);\n   * }\n   * ```\n   */\n  static from<SomeResource extends Resource<any>>(\n    this: Constructor<SomeResource>,\n    thunk: AsThunk<ArgsFrom<SomeResource>>,\n  ): SomeResource;\n\n  /**\n   * For use in the body of a class.\n   *\n   * `from` is what allows resources to be used in JS, they hide the reactivity APIs\n   * from the consumer so that the surface API is smaller.\n   * Though it _may_ be more convenient to not wrap your resource abstraction in a helper function.\n   *\n   * ```js\n   * import { Resource } from 'ember-resources';\n   *\n   * class SomeResource extends Resource {}\n   *\n   * class MyClass {\n   *   data = SomeResource.from(this, () => [ ... ]);\n   * }\n   * ```\n   *\n   * However, if you have argument defaults or need to change the shape of arguments\n   * depending on what ergonomics you want your users to have, a wrapper function\n   * may be better.\n   *\n   * ```js\n   * export function someResource(context, { foo, bar }) {\n   *   return SomeResource.from(context, () =>  ... );\n   * }\n   * ```\n   *  usage:\n   * ```js\n   * import { someResource } from 'your-library';\n   *\n   * class SomeResource extends Resource {}\n   *\n   * class MyClass {\n   *   @tracked foo;\n   *   @tracked bar;\n   *\n   *   data = someResource(this, {\n   *     foo: () => this.foo,\n   *     bar: () => this.bar\n   *   });\n   * }\n   * ```\n   */\n  static from<SomeResource extends Resource<any>>(\n    this: Constructor<SomeResource>,\n    context: unknown,\n    thunk: AsThunk<ArgsFrom<SomeResource>>,\n  ): SomeResource;\n\n  static from<SomeResource extends Resource<any>>(\n    this: Constructor<SomeResource>,\n    contextOrThunk: unknown | AsThunk<ArgsFrom<SomeResource>>,\n    thunkOrUndefined?: undefined | AsThunk<ArgsFrom<SomeResource>>,\n  ): SomeResource {\n    /**\n     * This first branch is for\n     *\n     * ```js\n     * class Foo {\n     *   @use foo = SomeResource.from(() => [ ... ])\n     * }\n     * ```\n     *\n     * and in order to support this, we need to defer the passed\n     * thunk until when the decorator is accessed.\n     *\n     * The decorator mostly does what `resourceOf` is doing below, but\n     * a little more simply, because we don't have to deal with a Proxy.\n     *\n     */\n    if (typeof contextOrThunk === 'function') {\n      /**\n       * We have to lie here because TypeScript doesn't allow decorators\n       * to alter the type of a property.\n       *\n       * This is private API that the `@use` decorator understands,\n       * but is not supported for use by any other conusmer.\n       */\n      return {\n        thunk: contextOrThunk,\n        definition: this,\n        type: 'class-based',\n        [INTERNAL]: true,\n      } as unknown as SomeResource;\n    }\n\n    /**\n     * This usage is for decorator-less usage\n     *\n     * ```js\n     * class Foo {\n     *   foo = SomeResource.from(this, () => [ ... ])\n     * }\n     * ```\n     *\n     * The only tradeoff is that a `this` needs to be passed.\n     *\n     */\n    return resourceOf(contextOrThunk, this, thunkOrUndefined);\n  }\n\n  // owner must be | unknown as to not\n  // break existing code\n  constructor(owner: Owner | unknown) {\n    setOwner(this, owner as Owner);\n\n    if (!loggedDeprecation) {\n      deprecate(\n        `This implementation of class-based resources is deprecated.and will be removed in ember-resources@v7. ` +\n          `The exact same code and support is available at https://github.com/NullVoxPopuli/ember-modify-based-class-resource. ` +\n          `\\`pnpm add ember-modify-based-class-resource\\` and then \\` import { Resource } from 'ember-modify-based-class-resource';\\`. ` +\n          `See also: https://github.com/NullVoxPopuli/ember-resources/issues/1056`,\n        false,\n        {\n          id: `ember-resources.class-based`,\n          until: `7.0.0`,\n          for: `ember-resources`,\n          url: `https://github.com/NullVoxPopuli/ember-modify-based-class-resource`,\n          since: {\n            available: '6.4.4',\n            enabled: '6.4.4',\n          },\n        },\n      );\n      loggedDeprecation = true;\n    }\n  }\n\n  /**\n   * this lifecycle hook is called whenever arguments to the resource change.\n   * This can be useful for calling functions, comparing previous values, etc.\n   *\n   * the two arguments, `positional`, and `named` will always be present, and\n   * can be assigned to properties on the class to use derived-from-args patterns.\n   * For example,\n   * ```js\n   * export class MyResource extends Resource {\n   *   modify(positional, named) {\n   *     this.positional = positional;\n   *     this.named = named;\n   *   }\n   *\n   *   get foo() {\n   *     return this.named.foo;\n   *   }\n   * }\n   * ```\n   * both the `positional` and `named` properties don't need to be tracked, because the\n   * objects they are set to are tracked internally -- and between `modify` calls,\n   * they are actually the same object. So in this example, after the first time `modify`\n   * is called, any subsequent calls to `modify` will be no-ops.\n   *\n   * This strategy is good for fine-grained reactivity in your resource because it allows\n   * your args to be individually consumed as needed. In the above example, accessing `foo`\n   * will entangle with the named arg, foo, so when that named arg changes, updates to your UI\n   * accessing MyResource's foo getter will also update, accordingly.\n   *\n   */\n  modify?(positional: Positional<Args>, named: Named<Args>): void;\n}\n\nfunction resourceOf<SomeResource extends Resource<unknown>>(\n  context: unknown,\n  klass: Constructor<SomeResource>,\n  thunk?: Thunk,\n): SomeResource {\n  assert(\n    `Expected second argument, klass, to be a Resource. ` +\n      `Instead, received some ${typeof klass}, ${klass.name}`,\n    klass.prototype instanceof Resource,\n  );\n\n  let cache: Cache<SomeResource>;\n\n  /*\n   * Having an object that we use invokeHelper + getValue on\n   * is how we convert the \"native class\" in to a reactive utility\n   * (along with the following proxy for accessing anything on this 'value')\n   *\n   */\n  let target = {\n    get value(): SomeResource {\n      if (!cache) {\n        cache = invokeHelper(context, klass, () => normalizeThunk(thunk || DEFAULT_THUNK));\n      }\n\n      return getValue<SomeResource>(cache);\n    },\n  };\n\n  /**\n   * This proxy takes everything called on or accessed on \"target\"\n   * and forwards it along to target.value (where the actual resource instance is)\n   *\n   * It's important to only access .value within these proxy-handler methods so that\n   * consumers \"reactively entangle with\" the Resource.\n   */\n  return new Proxy(target, {\n    get(target, key): unknown {\n      const instance = target.value as unknown as object;\n      const value = Reflect.get(instance, key, instance);\n\n      return typeof value === 'function' ? value.bind(instance) : value;\n    },\n\n    ownKeys(target): (string | symbol)[] {\n      const instance = target.value as unknown as object;\n\n      return Reflect.ownKeys(instance);\n    },\n\n    getOwnPropertyDescriptor(target, key): PropertyDescriptor | undefined {\n      const instance = target.value as unknown as object;\n\n      return Reflect.getOwnPropertyDescriptor(instance, key);\n    },\n  }) as never as SomeResource;\n}\n"],"names":["loggedDeprecation","Resource","from","contextOrThunk","thunkOrUndefined","thunk","definition","type","INTERNAL","resourceOf","constructor","owner","setOwner","deprecate","id","until","for","url","since","available","enabled","context","klass","assert","name","prototype","cache","target","value","invokeHelper","normalizeThunk","DEFAULT_THUNK","getValue","Proxy","get","key","instance","Reflect","bind","ownKeys","getOwnPropertyDescriptor"],"mappings":";;;;;;;AAAA;;AAcA;AACA;AACA;AAGA,IAAIA,iBAAiB,GAAG,KAAK,CAAA;;AAE7B;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,QAAQ,CAAiB;AACpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAME;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOE,EAAA,OAAOC,IAAIA,CAETC,cAAyD,EACzDC,gBAA8D,EAChD;AACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,IAAA,IAAI,OAAOD,cAAc,KAAK,UAAU,EAAE;AACxC;AACN;AACA;AACA;AACA;AACA;AACA;MACM,OAAO;AACLE,QAAAA,KAAK,EAAEF,cAAc;AACrBG,QAAAA,UAAU,EAAE,IAAI;AAChBC,QAAAA,IAAI,EAAE,aAAa;AACnB,QAAA,CAACC,QAAQ,GAAG,IAAA;OACb,CAAA;AACH,KAAA;;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,IAAA,OAAOC,UAAU,CAACN,cAAc,EAAE,IAAI,EAAEC,gBAAgB,CAAC,CAAA;AAC3D,GAAA;;AAEA;AACA;EACAM,WAAWA,CAACC,KAAsB,EAAE;AAClCC,IAAAA,QAAQ,CAAC,IAAI,EAAED,KAAc,CAAC,CAAA;IAE9B,IAAI,CAACX,iBAAiB,EAAE;MACtBa,SAAS,CACN,CAAuG,sGAAA,CAAA,GACrG,CAAqH,oHAAA,CAAA,GACrH,8HAA6H,GAC7H,CAAA,sEAAA,CAAuE,EAC1E,KAAK,EACL;AACEC,QAAAA,EAAE,EAAG,CAA4B,2BAAA,CAAA;AACjCC,QAAAA,KAAK,EAAG,CAAM,KAAA,CAAA;AACdC,QAAAA,GAAG,EAAG,CAAgB,eAAA,CAAA;AACtBC,QAAAA,GAAG,EAAG,CAAmE,kEAAA,CAAA;AACzEC,QAAAA,KAAK,EAAE;AACLC,UAAAA,SAAS,EAAE,OAAO;AAClBC,UAAAA,OAAO,EAAE,OAAA;AACX,SAAA;AACF,OACF,CAAC,CAAA;AACDpB,MAAAA,iBAAiB,GAAG,IAAI,CAAA;AAC1B,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAA;;AAEA,SAASS,UAAUA,CACjBY,OAAgB,EAChBC,KAAgC,EAChCjB,KAAa,EACC;AACdkB,EAAAA,MAAM,CACH,CAAoD,mDAAA,CAAA,GAClD,CAAyB,uBAAA,EAAA,OAAOD,KAAM,CAAIA,EAAAA,EAAAA,KAAK,CAACE,IAAK,EAAC,EACzDF,KAAK,CAACG,SAAS,YAAYxB,QAC7B,CAAC,CAAA;AAED,EAAA,IAAIyB,KAA0B,CAAA;;AAE9B;AACF;AACA;AACA;AACA;AACA;AACE,EAAA,IAAIC,MAAM,GAAG;IACX,IAAIC,KAAKA,GAAiB;MACxB,IAAI,CAACF,KAAK,EAAE;AACVA,QAAAA,KAAK,GAAGG,YAAY,CAACR,OAAO,EAAEC,KAAK,EAAE,MAAMQ,cAAc,CAACzB,KAAK,IAAI0B,aAAa,CAAC,CAAC,CAAA;AACpF,OAAA;MAEA,OAAOC,QAAQ,CAAeN,KAAK,CAAC,CAAA;AACtC,KAAA;GACD,CAAA;;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACE,EAAA,OAAO,IAAIO,KAAK,CAACN,MAAM,EAAE;AACvBO,IAAAA,GAAGA,CAACP,MAAM,EAAEQ,GAAG,EAAW;AACxB,MAAA,MAAMC,QAAQ,GAAGT,MAAM,CAACC,KAA0B,CAAA;MAClD,MAAMA,KAAK,GAAGS,OAAO,CAACH,GAAG,CAACE,QAAQ,EAAED,GAAG,EAAEC,QAAQ,CAAC,CAAA;AAElD,MAAA,OAAO,OAAOR,KAAK,KAAK,UAAU,GAAGA,KAAK,CAACU,IAAI,CAACF,QAAQ,CAAC,GAAGR,KAAK,CAAA;KAClE;IAEDW,OAAOA,CAACZ,MAAM,EAAuB;AACnC,MAAA,MAAMS,QAAQ,GAAGT,MAAM,CAACC,KAA0B,CAAA;AAElD,MAAA,OAAOS,OAAO,CAACE,OAAO,CAACH,QAAQ,CAAC,CAAA;KACjC;AAEDI,IAAAA,wBAAwBA,CAACb,MAAM,EAAEQ,GAAG,EAAkC;AACpE,MAAA,MAAMC,QAAQ,GAAGT,MAAM,CAACC,KAA0B,CAAA;AAElD,MAAA,OAAOS,OAAO,CAACG,wBAAwB,CAACJ,QAAQ,EAAED,GAAG,CAAC,CAAA;AACxD,KAAA;AACF,GAAC,CAAC,CAAA;AACJ;;;;"}