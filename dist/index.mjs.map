{"version":3,"file":"index.mjs","sources":["../src/types.ts","../src/cell.ts","../src/ember-compat.ts","../src/immediate-invocation-manager.ts","../src/resource-manager.ts","../src/use.ts","../src/utils.ts","../src/resource.ts"],"sourcesContent":["import type Owner from '@ember/owner';\nimport type { Invoke } from '@glint/template/-private/integration';\n\nexport interface Stage1DecoratorDescriptor {\n  initializer: () => unknown;\n}\n\nexport type Stage1Decorator = (\n  prototype: object,\n  key: string | symbol,\n  descriptor?: Stage1DecoratorDescriptor,\n) => any;\n\nexport const INTERMEDIATE_VALUE = '__Intermediate_Value__';\nexport const INTERNAL = '__INTERNAL__';\n\nexport interface InternalFunctionResourceConfig<Value = unknown> {\n  definition: ResourceFunction<Value>;\n  type: 'function-based';\n  name: string;\n  [INTERNAL]: true;\n}\n\nexport const CURRENT = Symbol('ember-resources::CURRENT') as unknown as 'CURRENT';\n\nexport interface GlintRenderable {\n  /**\n   * Cells aren't inherently understood by Glint,\n   * so to work around that, we'll hook in to the fact that\n   * ContentValue (the type expected for all renderables),\n   * defines an interface with this signature.\n   *\n   * (SafeString)\n   *\n   * There *has* been interest in the community to formally support\n   * toString and toHTML APIs across all objects. An RFC needs to be\n   * written so that we can gather feedback / potential problems.\n   */\n  toHTML(): string;\n}\n\n// Will need to be a class for .current flattening / auto-rendering\nexport interface Reactive<Value> extends GlintRenderable {\n  current: Value;\n  [CURRENT]: Value;\n  [Invoke]?: Value;\n}\n\n/**\n * This is the type of the arguments passed to the `resource` function\n *\n * ```ts\n * import { resource, type ResourceAPI } from 'ember-resources';\n *\n * export const Clock = resource((api: ResourceAPI) => {\n *   let { on, use, owner } = api;\n *\n *   // ...\n * })\n * ```\n */\nexport type ResourceAPI = {\n  on: {\n    /**\n     * Optionally a function-resource can provide a cleanup function.\n     *\n     *\n     *  Example:\n     *  ```js\n     *  import { resource } from 'ember-resources';\n     *  import { TrackedObject } from 'tracked-built-ins';\n     *\n     *  const load = resource(({ on }) => {\n     *    let state = new TrackedObject({});\n     *    let controller = new AbortController();\n     *\n     *    on.cleanup(() => controller.abort());\n     *\n     *    fetch(this.url, { signal: controller.signal })\n     *      // ...\n     *\n     *    return state;\n     *  })\n     */\n    cleanup: (destroyer: Destructor) => void;\n  };\n\n  /**\n   * Allows for composition of resources.\n   *\n   * Example:\n   * ```js\n   * let formatter = new Intl.DateTimeFormat(\"en-US\", {\n   *   hour: \"numeric\",\n   *   minute: \"numeric\",\n   *   second: \"numeric\",\n   *   hour12: false,\n   * });\n   * let format = (time: Reactive<Date>) => formatter.format(time.current);\n   *\n   * const Now = resource(({ on }) => {\n   *    let now = cell(nowDate);\n   *    let timer = setInterval(() => now.set(Date.now()), 1000);\n   *\n   *    on.cleanup(() => clearInterval(timer));\n   *\n   *    return () => now.current;\n   *  });\n   *\n   *  const Stopwatch = resource(({ use }) => {\n   *    let time = use(Now);\n   *\n   *     return () => format(time);\n   *  });\n   * ```\n   */\n  use: <Value>(resource: Value) => Reactive<Value extends Reactive<any> ? Value['current'] : Value>;\n  /**\n   * The Application owner.\n   * This allows for direct access to traditional ember services.\n   *\n   * Example:\n   * ```js\n   * resource(({ owner }) => {\n   *   owner.lookup('service:router').currentRouteName\n   *  //...\n   * }\n   * ```\n   */\n  owner: Owner;\n};\n\n/**\n * Type of the callback passed to `resource`\n */\nexport type ResourceFunction<Value = unknown> = (hooks: ResourceAPI) => Value | (() => Value);\n\n/**\n * The perceived return value of `resource`\n * This is a lie to TypeScript, because the effective value of\n * of the resource is the result of the collapsed functions\n * passed to `resource`\n */\nexport type ResourceFn<Value = unknown> = (hooks: ResourceAPI) => Value;\n\nexport type Destructor = () => void;\nexport type Cache = object;\n","import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\n\nexport class ReadonlyCell<Value> implements Reactive<Value> {\n  #getter: () => Value;\n\n  constructor(getter: () => Value) {\n    this.#getter = getter;\n  }\n\n  toHTML(): string {\n    assert(\n      'Not a valid API. Please access either .current or .read() if the value of this Cell is needed',\n    );\n  }\n\n  get [CURRENT](): Value {\n    return this.current;\n  }\n\n  get current(): Value {\n    return this.#getter();\n  }\n}\n\nexport class Cell<Value = unknown> implements Reactive<Value> {\n  @tracked declare current: Value;\n\n  get [CURRENT](): Value {\n    return this.current;\n  }\n\n  toHTML(): string {\n    assert(\n      'Not a valid API. Please access either .current or .read() if the value of this Cell is needed',\n    );\n  }\n\n  constructor();\n  constructor(initialValue: Value);\n  constructor(initialValue?: Value) {\n    if (initialValue !== undefined) {\n      this.current = initialValue;\n    }\n  }\n\n  /**\n   * Toggles the value of `current` only if\n   * `current` is a boolean -- errors otherwise\n   */\n  toggle = () => {\n    assert(\n      `toggle can only be used when 'current' is a boolean type`,\n      typeof this.current === 'boolean' || this.current === undefined,\n    );\n\n    (this.current as boolean) = !this.current;\n  };\n\n  /**\n   * Updates the value of `current`\n   * by calling a function that receives the previous value.\n   */\n  update = (updater: (prevValue: Value) => Value) => {\n    this.current = updater(this.current);\n  };\n\n  /**\n   * Updates the value of `current`\n   */\n  set = (nextValue: Value) => {\n    this.current = nextValue;\n  };\n\n  /**\n   * Returns the current value.\n   */\n  read = () => this.current;\n}\n\n/**\n * <div class=\"callout note\">\n *\n * This is not a core part of ember-resources, but is a useful utility when working with Resources. This utility is still under the broader library's SemVer policy. Additionally, the \"Cell\" is a core concept in Starbeam. See [Cells in Starbeam](https://www.starbeamjs.com/guides/fundamentals/cells.html)\n *\n * </div>\n *\n *\n * Small state utility for helping reduce the number of imports\n * when working with resources in isolation.\n *\n * The return value is an instance of a class with a single\n * `@tracked` property, `current`. If `current` is a boolean,\n * there is a `toggle` method available as well.\n *\n * For example, a Clock:\n *\n * ```js\n * import { resource, cell } from 'ember-resources';\n *\n * const Clock = resource(({ on }) => {\n *   let time = cell(new Date());\n *   let interval = setInterval(() => time.current = new Date(), 1000);\n *\n *   on.cleanup(() => clearInterval(interval));\n *\n *   let formatter = new Intl.DateTimeFormat('en-US', {\n *     hour: 'numeric',\n *     minute: 'numeric',\n *     second: 'numeric',\n *     hour12: true,\n *   });\n *\n *   return () => formatter.format(time.current);\n * });\n *\n * <template>\n *   It is: <time>{{Clock}}</time>\n * </template>\n * ```\n *\n * Additionally, cells can be directly rendered:\n * ```js\n * import { resource, cell } from 'ember-resources';\n *\n * const value = cell(0);\n *\n * <template>\n *    {{value}}\n * </template>\n * ```\n *\n */\nexport function cell<Value = unknown>(initialValue?: Value): Cell<Value> {\n  if (initialValue !== undefined) {\n    return new Cell(initialValue as Value);\n  }\n\n  return new Cell();\n}\n\n// @ts-ignore\nimport { capabilities as helperCapabilities, setHelperManager } from '@ember/helper';\n\nimport { CURRENT } from './types.ts';\n\nimport type { GlintRenderable, Reactive } from './types.ts';\n\nclass CellManager {\n  capabilities = helperCapabilities('3.23', {\n    hasValue: true,\n  });\n\n  createHelper(cell: Cell) {\n    return cell;\n  }\n\n  getValue(cell: Cell) {\n    return cell.current;\n  }\n}\n\nconst cellEvaluator = new CellManager();\n\nsetHelperManager(() => cellEvaluator, Cell.prototype);\nsetHelperManager(() => cellEvaluator, ReadonlyCell.prototype);\n","import { dependencySatisfies, importSync, macroCondition } from '@embroider/macros';\n\nimport type Owner from '@ember/owner';\n\ninterface CompatOwner {\n  getOwner: (context: unknown) => Owner | undefined;\n  setOwner: (context: unknown, owner: Owner) => void;\n}\n\nexport const compatOwner = {} as CompatOwner;\n\nif (macroCondition(dependencySatisfies('ember-source', '>=4.12.0'))) {\n  // In no version of ember where `@ember/owner` tried to be imported did it exist\n  // if (macroCondition(false)) {\n  // Using 'any' here because importSync can't lookup types correctly\n  compatOwner.getOwner = (importSync('@ember/owner') as any).getOwner;\n  compatOwner.setOwner = (importSync('@ember/owner') as any).setOwner;\n} else {\n  // Using 'any' here because importSync can't lookup types correctly\n  compatOwner.getOwner = (importSync('@ember/application') as any).getOwner;\n  compatOwner.setOwner = (importSync('@ember/application') as any).setOwner;\n}\n","// @ts-ignore\nimport { createCache, getValue } from '@glimmer/tracking/primitives/cache';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild, destroy } from '@ember/destroyable';\n// @ts-ignore\nimport { capabilities as helperCapabilities, invokeHelper, setHelperManager } from '@ember/helper';\n\nimport type { resource } from './resource.ts';\nimport type Owner from '@ember/owner';\n\ntype SpreadFor<T> = T extends Array<any> ? T : [T];\ntype ResourceFactory<Value = any, Args = any> = (...args: SpreadFor<Args>) => Value;\n\ninterface State {\n  cache: ReturnType<typeof invokeHelper>;\n}\n\nimport { compatOwner } from './ember-compat.ts';\n\nconst setOwner = compatOwner.setOwner;\n\nclass ResourceInvokerManager {\n  capabilities = helperCapabilities('3.23', {\n    hasValue: true,\n    hasDestroyable: true,\n  });\n\n  constructor(protected owner: Owner) {}\n\n  createHelper(fn: ResourceFactory, args: any): State {\n    let previous: object | undefined;\n    /**\n     * This cache is for args passed to the ResourceInvoker/Factory\n     *\n     * We want to cache the helper result, and only re-inoke when the args\n     * change.\n     */\n    const cache: State['cache'] = createCache(() => {\n      let resource = fn(...[...args.positional, args.named]) as object;\n\n      setOwner(resource, this.owner);\n\n      let result = invokeHelper(cache, resource);\n\n      if (previous) {\n        destroy(previous);\n      }\n\n      previous = result;\n\n      return result;\n    });\n\n    setOwner(cache, this.owner);\n\n    return { cache };\n  }\n\n  /**\n   * getValue is re-called when args change\n   */\n  getValue({ cache }: State) {\n    // SAFETY: we have a nested cache here\n    let resource = getValue(cache) as ReturnType<typeof invokeHelper>;\n\n    associateDestroyableChild(cache, resource);\n\n    return getValue(resource);\n  }\n\n  getDestroyable({ cache }: State) {\n    /**\n     * This is the parent cache, from `createHelper`\n     */\n    return cache;\n  }\n}\n\n/**\n * Allows wrapper functions to provide a [[resource]] for use in templates.\n *\n * Only library authors may care about this, but helper function is needed to \"register\"\n * the wrapper function with a helper manager that specifically handles invoking both the\n * resource wrapper function as well as the underlying resource.\n *\n * _App-devs / consumers may not ever need to know this utility function exists_\n *\n *  Example using strict mode + `<template>` syntax and a template-only component:\n *  ```js\n *  import { resource, resourceFactory } from 'ember-resources';\n *\n *  function RemoteData(url) {\n *    return resource(({ on }) => {\n *      let state = new TrackedObject({});\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      fetch(url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *        })\n *        .catch(error => {\n *          state.error = error;\n *        });\n *\n *      return state;\n *    })\n * }\n *\n * resourceFactory(RemoteData);\n *\n *  <template>\n *    {{#let (RemoteData \"http://....\") as |state|}}\n *      {{#if state.value}}\n *        ...\n *      {{else if state.error}}\n *        {{state.error}}\n *      {{/if}}\n *    {{/let}}\n *  </template>\n *  ```\n *\n *  Alternatively, `resourceFactory` can wrap the wrapper function.\n *\n *  ```js\n *  const RemoteData = resourceFactory((url) => {\n *    return resource(({ on }) => {\n *      ...\n *    });\n *  })\n *  ```\n */\nexport function resourceFactory<Value = unknown, Args extends any[] = any[]>(\n  wrapperFn: (...args: Args) => ReturnType<typeof resource<Value>>,\n  /**\n   * This is a bonkers return type.\n   * Here are the scenarios:\n   *   const A = resourceFactory((...args) => {\n   *     return resource(({ on }) => {\n   *       ...\n   *     })\n   *   })\n   *\n   * Invocation styles need to be type-correct:\n   *   @use a = A(() => [b, c, d])\n   *   => single argument which is a function where the return type is the args\n   *\n   *   {{#let (A b c d) as |a|}}\n   *      {{a}}\n   *   {{/let}}\n   *   => args are passed directly as positional arguments\n   */\n) {\n  setHelperManager(ResourceInvokerFactory, wrapperFn);\n\n  return wrapperFn as ResourceBlueprint<Value, Args>;\n}\n\ntype ResourceBlueprint<Value, Args> =\n  /**\n   * Type for template invocation\n   *  {{#let (A b c d) as |a|}}\n   *     {{a}}\n   *  {{/let}}\n   *\n   * This could also be used in JS w/ invocation with @use\n   *   @use a = A(() => b)\n   *\n   * NOTE: it is up to the function passed to resourceFactory to handle some of the parameter ambiguity\n   */\n  | ((...args: SpreadFor<Args>) => ReturnType<typeof resource<Value>>)\n  /**\n   * Not passing args is allowed, too\n   *   @use a = A()\n   *\n   *   {{A}}\n   */\n  | (() => ReturnType<typeof resource<Value>>);\n// semicolon\n\n// Provide a singleton manager.\nconst ResourceInvokerFactory = (owner: Owner | undefined) => {\n  assert(`Cannot create resource without an owner`, owner);\n\n  return new ResourceInvokerManager(owner);\n};\n","// @ts-ignore\nimport { createCache, getValue } from '@glimmer/tracking/primitives/cache';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild, destroy, registerDestructor } from '@ember/destroyable';\n// @ts-ignore\nimport { invokeHelper } from '@ember/helper';\n// @ts-ignore\nimport { capabilities as helperCapabilities } from '@ember/helper';\n\nimport { ReadonlyCell } from './cell.ts';\nimport { compatOwner } from './ember-compat.ts';\nimport { CURRENT, INTERNAL } from './types.ts';\n\nimport type {\n  Destructor,\n  InternalFunctionResourceConfig,\n  Reactive,\n  ResourceFunction,\n} from './types.ts';\nimport type Owner from '@ember/owner';\n\nconst setOwner = compatOwner.setOwner;\n\n/**\n * Note, a function-resource receives on object, hooks.\n *    We have to build that manually in this helper manager\n */\nclass FunctionResourceManager {\n  capabilities: ReturnType<typeof helperCapabilities> = helperCapabilities('3.23', {\n    hasValue: true,\n    hasDestroyable: true,\n  });\n\n  constructor(protected owner: Owner) {}\n\n  /**\n   * Resources do not take args.\n   * However, they can access tracked data\n   */\n  createHelper(config: InternalFunctionResourceConfig): {\n    fn: InternalFunctionResourceConfig['definition'];\n    cache: ReturnType<typeof invokeHelper>;\n  } {\n    let { definition: fn } = config;\n    /**\n     * We have to copy the `fn` in case there are multiple\n     * usages or invocations of the function.\n     *\n     * This copy is what we'll ultimately work with and eventually\n     * destroy.\n     */\n    let thisFn = fn.bind(null);\n    let previousFn: object;\n    let usableCache = new WeakMap<object, ReturnType<typeof invokeHelper>>();\n    let owner = this.owner;\n\n    let cache = createCache(() => {\n      if (previousFn) {\n        destroy(previousFn);\n      }\n\n      let currentFn = thisFn.bind(null);\n\n      associateDestroyableChild(thisFn, currentFn);\n      previousFn = currentFn;\n\n      let maybeValue = currentFn({\n        on: {\n          cleanup: (destroyer: Destructor) => {\n            registerDestructor(currentFn, destroyer);\n          },\n        },\n        use: (usable) => {\n          assert(\n            `Expected the resource's \\`use(...)\\` utility to have been passed an object, but a \\`${typeof usable}\\` was passed.`,\n            typeof usable === 'object',\n          );\n          assert(\n            `Expected the resource's \\`use(...)\\` utility to have been passed a truthy value, instead was passed: ${usable}.`,\n            usable,\n          );\n          assert(\n            `Expected the resource's \\`use(...)\\` utility to have been passed another resource, but something else was passed.`,\n            INTERNAL in usable,\n          );\n\n          let previousCache = usableCache.get(usable);\n\n          if (previousCache) {\n            destroy(previousCache);\n          }\n\n          let nestedCache = invokeHelper(cache, usable);\n\n          associateDestroyableChild(currentFn, nestedCache as object);\n\n          usableCache.set(usable, nestedCache);\n\n          return new ReadonlyCell<any>(() => {\n            let cache = usableCache.get(usable);\n\n            assert(`Cache went missing while evaluating the result of a resource.`, cache);\n\n            return getValue(cache);\n          });\n        },\n        owner: this.owner,\n      });\n\n      return maybeValue;\n    });\n\n    setOwner(cache, owner);\n\n    return { fn: thisFn, cache };\n  }\n\n  getValue({ cache }: { fn: ResourceFunction; cache: ReturnType<typeof invokeHelper> }) {\n    let maybeValue = getValue(cache);\n\n    if (typeof maybeValue === 'function') {\n      return maybeValue();\n    }\n\n    if (isReactive(maybeValue)) {\n      return maybeValue[CURRENT];\n    }\n\n    return maybeValue;\n  }\n\n  getDestroyable({ fn }: { fn: ResourceFunction }) {\n    return fn;\n  }\n}\n\nfunction isReactive<Value>(maybe: unknown): maybe is Reactive<Value> {\n  return typeof maybe === 'object' && maybe !== null && CURRENT in maybe;\n}\n\nexport const ResourceManagerFactory = (owner: Owner | undefined) => {\n  assert(`Cannot create resource without an owner`, owner);\n\n  return new FunctionResourceManager(owner);\n};\n","// NOTE: https://2ality.com/2022/10/javascript-decorators.html#class-getter-decorators%2C-class-setter-decorators\n// (for spec decorators, when it comes time to implement those)\n//\n// @ts-ignore\nimport { getValue } from '@glimmer/tracking/primitives/cache';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild } from '@ember/destroyable';\n// @ts-ignore\nimport { invokeHelper } from '@ember/helper';\n\nimport { ReadonlyCell } from './cell.ts';\n\nimport type {\n  INTERNAL,\n  InternalFunctionResourceConfig,\n  Reactive,\n  Stage1DecoratorDescriptor,\n} from './types.ts';\n\ntype Config =\n  | { [INTERNAL]: true; type: string; definition: unknown }\n  | InternalFunctionResourceConfig;\n\ntype NonInstanceType<K> = K extends InstanceType<any> ? object : K;\ntype DecoratorKey<K> = K extends string | symbol ? K : never;\n\n/**\n * The `@use(...)` decorator can be used to use a Resource in javascript classes\n *\n * ```js\n * import { resource, use } from 'ember-resources';\n *\n * const Clock = resource( ... );\n *\n * class Demo {\n *   @use(Clock) time;\n * }\n * ```\n */\nexport function use<Value>(definition: Value | (() => Value)): PropertyDecorator;\n\n/**\n * The `@use` decorator can be used to use a Resource in javascript classes\n *\n * ```js\n * import { resource, use } from 'ember-resources';\n *\n * const Clock = resource(() => 2);\n *\n * class MyClass {\n *   @use data = Clock;\n * }\n *\n * (new MyClass()).data === 2\n * ```\n */\nexport function use<Prototype, Key>(\n  prototype: NonInstanceType<Prototype>,\n  key: DecoratorKey<Key>,\n  descriptor?: Stage1DecoratorDescriptor,\n): void;\n\n/**\n * The `use function can be used to use a Resource in javascript classes\n *\n * Note that when using this version of `use`, the value is only accessible on the `current`\n * property.\n *\n * ```js\n * import { resource, use } from 'ember-resources';\n *\n * const Clock = resource( ... );\n *\n * class Demo {\n *   data = use(this, Clock);\n * }\n *\n * (new Demo()).data.current === 2\n * ```\n */\nexport function use<Value>(\n  parent: object,\n  definition: Value | (() => Value),\n  _?: never,\n): Reactive<Value extends Reactive<any> ? Value['current'] : Value>;\n\nexport function use(\n  ...args:\n    | Parameters<typeof initializerDecorator>\n    | Parameters<typeof argumentToDecorator>\n    | Parameters<typeof classContextLink>\n) {\n  if (args.length === 3) {\n    return initializerDecorator(...args);\n  }\n\n  if (args.length === 2) {\n    if (typeof args[1] !== 'string' && typeof args[1] !== 'symbol') {\n      return classContextLink(args[0], args[1]);\n    }\n  }\n\n  if (args.length === 1) {\n    return argumentToDecorator(args[0]);\n  }\n\n  assert(`Unknown arity for \\`use\\`. Received ${args.length} arguments`, false);\n}\n\nfunction getCurrentValue<Value>(value: Value | Reactive<Value>): Value {\n  /**\n   * If we are working with a cell, forward the '.current' call to it.\n   */\n  if (typeof value === 'object' && value !== null && 'current' in value) {\n    return value.current;\n  }\n\n  return value;\n}\n\nfunction classContextLink<Value>(\n  context: object,\n  definition: Value | (() => Value),\n): Reactive<Value> {\n  let cache: ReturnType<typeof invokeHelper>;\n\n  return new ReadonlyCell<Value>(() => {\n    if (!cache) {\n      cache = invokeHelper(context, definition as object);\n\n      associateDestroyableChild(context, cache);\n    }\n\n    let value = getValue(cache);\n\n    return getCurrentValue(value) as Value;\n  });\n}\n\nfunction argumentToDecorator<Value>(definition: Value | (() => Value)): PropertyDecorator {\n  return (\n    _prototype: object,\n    key: string | symbol,\n    descriptor?: Stage1DecoratorDescriptor,\n  ): void => {\n    // TS's types for decorators use the Stage2 implementation, even though Babel uses Stage 1\n    if (!descriptor) return;\n\n    assert(`@use can only be used with string-keys`, typeof key === 'string');\n\n    assert(\n      `When @use(...) is passed a resource, an initialized value is not allowed. ` +\n        `\\`@use(Clock) time;`,\n      !descriptor.initializer,\n    );\n\n    let newDescriptor = descriptorGetter(definition);\n\n    return newDescriptor as unknown as void /* Thanks, TS and Stage 2 Decorators */;\n  };\n}\n\ninterface UsableConfig {\n  type: string;\n  definition: unknown;\n}\n\nexport type UsableFn<Usable extends UsableConfig> = (\n  context: object,\n  config: Usable,\n  // This return type *would be* ReturnType<typeof invokeHelper>\n  // But the DT types for @ember/helper don't have *any* of the helper-manager things.\n) => unknown;\n\nconst USABLES = new Map<string, UsableFn<any>>();\n\n/**\n * Register with the usable system.\n * This is only needed for for the `@use` decorator, as use(this, Helper) is a concise wrapper\n * around the helper-manager system.\n *\n * The return type must be a \"Cache\" returned from `invokeHelper` so that `@use`'s usage of `getValue` gets the value (as determined by the helper manager you wrote for your usable).\n */\nexport function registerUsable<Usable extends UsableConfig>(\n  /**\n   * The key to register the usable under.\n   *\n   * All usables must have a `type`.\n   *\n   * Any usable matching the registered type will used the passed function to\n   *   create its Cache -- this is typically the return result of `invokeHelper`,\n   *\n   * Any usables must have a `type` property matching this string\n   */\n  type: string,\n  /**\n   * Receives the the parent context and object passed to the `@use` decorator.\n   */\n  useFn: UsableFn<Usable>,\n) {\n  assert(`type may not overlap with an existing usable`, !USABLES.has(type));\n\n  USABLES.set(type, useFn);\n}\n\nfunction descriptorGetter(initializer: unknown | (() => unknown)) {\n  let caches = new WeakMap<object, any>();\n\n  return {\n    get(this: object) {\n      let cache = caches.get(this);\n\n      if (!cache) {\n        let config = (\n          typeof initializer === 'function' ? initializer.call(this) : initializer\n        ) as Config;\n\n        let usable = USABLES.get(config.type);\n\n        assert(\n          `Expected the initialized value with @use to have been a registerd \"usable\". Available usables are: ${[\n            ...USABLES.keys(),\n          ]}`,\n          usable,\n        );\n\n        cache = usable(this, config);\n\n        assert(`Failed to create cache for usable: ${config.type}`, cache);\n\n        caches.set(this as object, cache);\n        associateDestroyableChild(this, cache);\n      }\n\n      let value = getValue(cache);\n\n      return getCurrentValue(value);\n    },\n  };\n}\n\nfunction initializerDecorator(\n  _prototype: object,\n  key: string | symbol,\n  descriptor?: Stage1DecoratorDescriptor,\n): void {\n  // TS's types for decorators use the Stage2 implementation, even though Babel uses Stage 1\n  if (!descriptor) return;\n\n  assert(`@use can only be used with string-keys`, typeof key === 'string');\n\n  let { initializer } = descriptor;\n\n  assert(\n    `@use may only be used on initialized properties. For example, ` +\n      `\\`@use foo = resource(() => { ... })\\` or ` +\n      `\\`@use foo = SomeResource.from(() => { ... });\\``,\n    initializer,\n  );\n\n  return descriptorGetter(initializer) as unknown as void /* Thanks, TS and Stage 2 Decorators */;\n}\n","// @ts-ignore\nimport { getValue } from '@glimmer/tracking/primitives/cache';\nimport { assert } from '@ember/debug';\n// @ts-ignore\nimport { invokeHelper } from '@ember/helper';\n\nimport { INTERMEDIATE_VALUE } from './types.ts';\n\nimport type { InternalFunctionResourceConfig } from './types.ts';\n\n/**\n * This is what allows resource to be used withotu @use.\n * The caveat though is that a property must be accessed\n * on the return object.\n *\n * A resource not using use *must* be an object.\n */\nexport function wrapForPlainUsage<Value>(\n  context: object,\n  setup: InternalFunctionResourceConfig<Value>,\n) {\n  let cache: ReturnType<typeof invokeHelper>;\n\n  /*\n   * Having an object that we use invokeHelper + getValue on\n   * is how we convert the \"function\" in to a reactive utility\n   * (along with the following proxy for accessing anything on this 'value')\n   *\n   */\n  const target = {\n    get [INTERMEDIATE_VALUE]() {\n      if (!cache) {\n        cache = invokeHelper(context, setup);\n      }\n\n      // SAFETY: the types for the helper manager APIs aren't fully defined to infer\n      //         nor allow passing the value.\n      return getValue<Value>(cache as any);\n    },\n  };\n\n  /**\n   * This proxy takes everything called on or accessed on \"target\"\n   * and forwards it along to target[INTERMEDIATE_VALUE] (where the actual resource instance is)\n   *\n   * It's important to only access .[INTERMEDIATE_VALUE] within these proxy-handler methods so that\n   * consumers \"reactively entangle with\" the Resource.\n   */\n  return new Proxy(target, {\n    get(target, key): unknown {\n      const state = target[INTERMEDIATE_VALUE];\n\n      assert('[BUG]: it should not have been possible for this to be undefined', state);\n\n      return Reflect.get(state, key, state);\n    },\n\n    ownKeys(target): (string | symbol)[] {\n      const value = target[INTERMEDIATE_VALUE];\n\n      assert('[BUG]: it should not have been possible for this to be undefined', value);\n\n      return Reflect.ownKeys(value);\n    },\n\n    getOwnPropertyDescriptor(target, key): PropertyDescriptor | undefined {\n      const value = target[INTERMEDIATE_VALUE];\n\n      assert('[BUG]: it should not have been possible for this to be undefined', value);\n\n      return Reflect.getOwnPropertyDescriptor(value, key);\n    },\n  }) as never as Value;\n}\n","import { assert } from '@ember/debug';\n// @ts-ignore\nimport { invokeHelper, setHelperManager } from '@ember/helper';\n\nimport { ResourceManagerFactory } from './resource-manager.ts';\nimport { INTERNAL } from './types.ts';\nimport { registerUsable } from './use.ts';\nimport { wrapForPlainUsage } from './utils.ts';\n\nimport type { InternalFunctionResourceConfig, ResourceFn, ResourceFunction } from './types.ts';\n\nconst TYPE = 'function-based';\n\nregisterUsable(TYPE, (context: object, config: InternalFunctionResourceConfig) => {\n  return invokeHelper(context, config);\n});\n\n/**\n * `resource` provides a single reactive read-only value with lifetime and may have cleanup.\n *\n * Arguments passed to the `resource` function:\n * ```js\n *  resource(\n *    ({\n *      // provided callback functions:\n *      //  - `cleanup`\n *      on,\n *\n *      // used for composing other resources\n *      use,\n *\n *      // used for accessing services, etc on the app/engine owner instance\n *      owner\n *    }) => {\n *      // ✂️  resource body ✂️\n *    }\n *  );\n *  ```\n *\n *  Example using `fetch` + `AbortController`\n *  ```js\n *  import { use, resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *  import { tracked } from '@glimmer/tracking';\n *\n *  class Demo {\n *    @tracked url = '...';\n *\n *    @use myData = resource(({ on }) => {\n *      let state = new TrackedObject({ ... });\n *\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      // because this.url is tracked, anytime url changes,\n *      // this resource will re-run\n *      fetch(this.url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *          // ...\n *        })\n *        .catch(error => {\n *          state.error = error;\n *          // ...\n *        });\n *      // Note that this fetch request could be written async by wrapping in an\n *      // immediately invoked async function, e.g: (async () => {})()\n *\n *\n *      return state;\n *    })\n *  }\n *  ```\n *\n *\n *\n *  Example using strict mode + `<template>` syntax and a template-only component:\n *\n *  ```js\n *  import { resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *\n *  const load = resource(({ on }) => {\n *    let state = new TrackedObject({});\n *    let controller = new AbortController();\n *\n *    on.cleanup(() => controller.abort());\n *\n *    fetch(this.url, { signal: controller.signal })\n *      .then(response => response.json())\n *      .then(data => {\n *        state.value = data;\n *      })\n *      .catch(error => {\n *        state.error = error;\n *      });\n *\n *    return state;\n *  })\n *\n *  <template>\n *    {{#let (load) as |state|}}\n *      {{#if state.value}}\n *        ...\n *      {{else if state.error}}\n *        {{state.error}}\n *      {{/if}}\n *    {{/let}}\n *  </template>\n *  ```\n */\nexport function resource<Value>(setup: ResourceFunction<Value>): Value;\n\n/**\n * `resource` is an alternative API to the class-based `Resource`.\n * It may provide a single read-only value and provides a way to optionally cleanup.\n *\n * When would you reach for the class-based `Resource`?\n *  - the capabilities of the function-based resource and class-based resource are identical,\n *    with the exception that function-based resources may represent a single value, rather than\n *    an object with properties/methods (the only option with class-based resources)\n *\n * A function-resource\n *  - _must_ return a value.\n *  - cannot, itself, be async - but can interact with promises and update a value\n *\n *  Example using `fetch` + `AbortController`\n *  ```js\n *  import { resource } from 'ember-resources';\n *  import { TrackedObject } from 'tracked-built-ins';\n *  import { tracked } from '@glimmer/tracking';\n *\n *  class Demo {\n *    @tracked url = '...';\n *\n *    myData = resource(this, ({ on }) => {\n *      let state = new TrackedObject({ isResolved: false, isLoading: true, isError: false });\n *\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      // because this.url is tracked, anytime url changes,\n *      // this resource will re-run\n *      fetch(this.url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *          state.isResolved = true;\n *          state.isLoading = false;\n *          state.isError = false;\n *        })\n *        .catch(error => {\n *          state.error = error;\n *          state.isResolved = true;\n *          state.isLoading = false;\n *          state.isError = true;\n *        });\n *      // Note that this fetch request could be written async by wrapping in an\n *      // immediately invoked async function, e.g: (async () => {})()\n *\n *\n *      return state;\n *    })\n *  }\n *  ```\n */\nexport function resource<Value>(context: object, setup: ResourceFunction<Value>): Value;\n\n/**\n */\nexport function resource<Value>(\n  context: object | ResourceFunction<Value>,\n  setup?: ResourceFunction<Value>,\n): Value | InternalFunctionResourceConfig<Value> | ResourceFn<Value> {\n  if (!setup) {\n    assert(\n      `When using \\`resource\\` with @use, ` +\n        `the first argument to \\`resource\\` must be a function. ` +\n        `Instead, a ${typeof context} was received.`,\n      typeof context === 'function',\n    );\n\n    let internalConfig: InternalFunctionResourceConfig<Value> = {\n      definition: context as ResourceFunction<Value>,\n      type: 'function-based',\n      name: 'Resource',\n      [INTERNAL]: true,\n    };\n\n    /**\n     * Functions have a different identity every time they are defined.\n     * The primary purpose of the `resource` wrapper is to individually\n     * register each function with our helper manager.\n     */\n    setHelperManager(ResourceManagerFactory, internalConfig);\n\n    /**\n     * With only one argument, we have to do a bunch of lying to\n     * TS, because we need a special object to pass to `@use`\n     *\n     * Add secret key to help @use assert against\n     * using vanilla functions as resources without the resource wrapper\n     *\n     */\n    return internalConfig as unknown as ResourceFn<Value>;\n  }\n\n  assert(\n    `Mismatched argument types passed to \\`resource\\`. ` +\n      `Expected the first arg, the context, to be a type of object. This is usually the \\`this\\`. ` +\n      `Received ${typeof context} instead.`,\n    typeof context === 'object',\n  );\n  assert(\n    `Mismatched argument type passed to \\`resource\\`. ` +\n      `Expected the second arg to be a function but instead received ${typeof setup}.`,\n    typeof setup === 'function',\n  );\n\n  let internalConfig: InternalFunctionResourceConfig<Value> = {\n    definition: setup as ResourceFunction<Value>,\n    type: TYPE,\n    name: getDebugName(setup),\n    [INTERNAL]: true,\n  };\n\n  setHelperManager(ResourceManagerFactory, internalConfig);\n\n  return wrapForPlainUsage(context, internalConfig);\n}\n\nfunction getDebugName(obj: object) {\n  if ('name' in obj) {\n    return `Resource Function: ${obj.name}`;\n  }\n\n  return `Resource Function`;\n}\n"],"names":["helperCapabilities","cell","setOwner","resource","cache","target","internalConfig"],"mappings":"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"}